{"version":3,"file":"textureSampleLevel.spec.js","names":["description","makeTestGroup","isCompressedTextureFormat","isDepthTextureFormat","isEncodableTextureFormat","kCompressedTextureFormats","kDepthStencilFormats","kEncodableTextureFormats","kShaderStages","appendComponentTypeForFormatToTextureType","checkCallResults","chooseTextureSize","createTextureWithRandomDataAndGetTexels","doTextureCalls","generateSamplePointsCube","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","getDepthOrArrayLayersForViewDimension","getTextureTypeForTextureViewDimension","isPotentiallyFilterableAndFillable","kCubeSamplePointMethods","kSamplePointMethods","skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable","WGSLTextureSampleTest","kTestableColorFormats","g","test","specURL","desc","params","u","combine","filter","t","format","beginSubcases","beforeAllSubcases","fn","stage","samplePoints","addressModeU","addressModeV","minFilter","offset","width","height","minSize","minBlocks","descriptor","size","mipLevelCount","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","texels","texture","sampler","magFilter","mipmapFilter","calls","method","mipLevel","num","type","hashInputs","map","coords","builtin","coordType","levelType","textureType","viewDescriptor","results","res","expectOK","A","depthOrArrayLayers","arrayIndex","arrayIndexType","viewDimension","addressMode","dimension","isCompatibility","textureBindingViewDimension","addressModeW","skipIfTextureViewDimensionNotSupported","L","combineWithParams","undefined"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureSampleLevel.spec.ts"],"sourcesContent":["export const description = `\nSamples a texture.\n\n- TODO: Test un-encodable formats.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport {\n  isCompressedTextureFormat,\n  isDepthTextureFormat,\n  isEncodableTextureFormat,\n  kCompressedTextureFormats,\n  kDepthStencilFormats,\n  kEncodableTextureFormats,\n} from '../../../../../format_info.js';\nimport { kShaderStages } from '../../../../validation/decl/util.js';\n\nimport {\n  appendComponentTypeForFormatToTextureType,\n  checkCallResults,\n  chooseTextureSize,\n  createTextureWithRandomDataAndGetTexels,\n  doTextureCalls,\n  generateSamplePointsCube,\n  generateTextureBuiltinInputs2D,\n  generateTextureBuiltinInputs3D,\n  getDepthOrArrayLayersForViewDimension,\n  getTextureTypeForTextureViewDimension,\n  isPotentiallyFilterableAndFillable,\n  kCubeSamplePointMethods,\n  kSamplePointMethods,\n  SamplePointMethods,\n  skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable,\n  TextureCall,\n  vec2,\n  vec3,\n  WGSLTextureSampleTest,\n} from './texture_utils.js';\n\nconst kTestableColorFormats = [...kEncodableTextureFormats, ...kCompressedTextureFormats] as const;\n\nexport const g = makeTestGroup(WGSLTextureSampleTest);\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nfn textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32) -> vec4<f32>\nfn textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('addressModeU', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('addressModeV', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('offset', [false, true] as const)\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, addressModeU, addressModeV, minFilter, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU,\n      addressModeV,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      offset,\n      hashInputs: [stage, format, samplePoints, addressModeU, addressModeV, minFilter, offset],\n    }).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_2d', format);\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, level: f32) -> vec4<f32>\nfn textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, level: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('addressModeU', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('addressModeV', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('offset', [false, true] as const)\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, A, addressModeU, addressModeV, minFilter, offset } =\n      t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const depthOrArrayLayers = 4;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU,\n      addressModeV,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      offset,\n      hashInputs: [stage, format, samplePoints, A, addressModeU, addressModeV, minFilter, offset],\n    }).map(({ coords, mipLevel, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_2d_array', format);\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nfn textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>\nfn textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32, offset: vec3<i32>) -> vec4<f32>\nfn textureSampleLevel(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('viewDimension', ['3d', 'cube'] as const)\n      .filter(t => !isCompressedTextureFormat(t.format) || t.viewDimension === 'cube')\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .filter(t => t.samplePoints !== 'cube-edges' || t.viewDimension !== '3d')\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('offset', [false, true] as const)\n      .filter(t => t.viewDimension !== 'cube' || t.offset !== true)\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const { format, viewDimension, stage, samplePoints, addressMode, minFilter, offset } = t.params;\n\n    const [width, height] = chooseTextureSize({ minSize: 32, minBlocks: 2, format, viewDimension });\n    const depthOrArrayLayers = getDepthOrArrayLayersForViewDimension(viewDimension);\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: viewDimension === '3d' ? '3d' : '2d',\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      addressModeW: addressMode,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const hashInputs = [stage, format, viewDimension, samplePoints, addressMode, minFilter, offset];\n    const calls: TextureCall<vec3>[] = (\n      viewDimension === '3d'\n        ? generateTextureBuiltinInputs3D(50, {\n            method: samplePoints as SamplePointMethods,\n            sampler,\n            descriptor,\n            mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n            offset,\n            hashInputs,\n          })\n        : generateSamplePointsCube(50, {\n            method: samplePoints,\n            sampler,\n            descriptor,\n            mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n            hashInputs,\n          })\n    ).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        offset,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nA is i32 or u32\n\nfn textureSampleLevel(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: A, level: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n\n- TODO: set mipLevelCount to 3 for cubemaps. See MAINTENANCE_TODO below\n\n  The issue is sampling a corner of a cubemap is undefined. We try to quantize coordinates\n  so we never get a corner but when sampling smaller mip levels that's more difficult.\n\n  * Solution 1: Fix the quantization\n  * Solution 2: special case checking cube corners. Expect some value between the color of the 3 corner texels.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n  )\n  .beforeAllSubcases(t => {\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format);\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n  })\n  .fn(async t => {\n    const { format, stage, samplePoints, A, addressMode, minFilter } = t.params;\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      addressModeW: addressMode,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      hashInputs: [stage, format, viewDimension, A, samplePoints, addressMode, minFilter],\n    }).map(({ coords, mipLevel, arrayIndex }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nL is i32 or u32\n\nfn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: L) -> f32\nfn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: L, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('L', ['i32', 'u32'] as const)\n      .combine('offset', [false, true] as const)\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, addressMode, minFilter, L, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount, type: L },\n      offset,\n      hashInputs: [stage, format, samplePoints, addressMode, minFilter, L, offset],\n    }).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: L === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_depth_2d', format);\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nA is i32 or u32\nL is i32 or u32\n\nfn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A, level: L) -> f32\nfn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A, level: L, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * array_index The 0-based texture array index to sample.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('L', ['i32', 'u32'] as const)\n      .combine('offset', [false, true] as const)\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, addressMode, minFilter, A, L, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      ...(t.isCompatibility && { textureBindingViewDimension: '2d-array' }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      mipLevel: { num: texture.mipLevelCount, type: L },\n      offset,\n      hashInputs: [stage, format, samplePoints, addressMode, minFilter, L, A, offset],\n    }).map(({ coords, mipLevel, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: L === 'i32' ? 'i' : 'u',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_depth_2d_array', format);\n    const viewDescriptor: GPUTextureViewDescriptor = { dimension: '2d-array' };\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nL is i32 or u32\nA is i32 or u32\n\nfn textureSampleLevel(t: texture_depth_cube, s: sampler, coords: vec3<f32>, level: L) -> f32\nfn textureSampleLevel(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: A, level: L) -> f32\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combineWithParams([\n        { viewDimension: 'cube' },\n        { viewDimension: 'cube-array', A: 'i32' },\n        { viewDimension: 'cube-array', A: 'u32' },\n      ] as const)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('L', ['i32', 'u32'] as const)\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n  )\n  .beforeAllSubcases(t => {\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format);\n    t.skipIfTextureViewDimensionNotSupported(t.params.viewDimension);\n  })\n  .fn(async t => {\n    const { format, stage, viewDimension, samplePoints, A, L, addressMode, minFilter } = t.params;\n\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      addressModeW: addressMode,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount - 1, type: L },\n      arrayIndex: A ? { num: texture.depthOrArrayLayers / 6, type: A } : undefined,\n      hashInputs: [stage, format, viewDimension, samplePoints, addressMode, minFilter],\n    }).map(({ coords, mipLevel, arrayIndex }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: L === 'i32' ? 'i' : 'u',\n        arrayIndex,\n        arrayIndexType: A ? (A === 'i32' ? 'i' : 'u') : undefined,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType =\n      viewDimension === 'cube' ? 'texture_depth_cube' : 'texture_depth_cube_array';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage\n    );\n    t.expectOK(res);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,kDAAkD;AAChF;EACEC,yBAAyB;EACzBC,oBAAoB;EACpBC,wBAAwB;EACxBC,yBAAyB;EACzBC,oBAAoB;EACpBC,wBAAwB;AACnB,+BAA+B;AACtC,SAASC,aAAa,QAAQ,qCAAqC;;AAEnE;EACEC,yCAAyC;EACzCC,gBAAgB;EAChBC,iBAAiB;EACjBC,uCAAuC;EACvCC,cAAc;EACdC,wBAAwB;EACxBC,8BAA8B;EAC9BC,8BAA8B;EAC9BC,qCAAqC;EACrCC,qCAAqC;EACrCC,kCAAkC;EAClCC,uBAAuB;EACvBC,mBAAmB;;EAEnBC,0DAA0D;;;;EAI1DC,qBAAqB;AAChB,oBAAoB;;AAE3B,MAAMC,qBAAqB,GAAG,CAAC,GAAGjB,wBAAwB,EAAE,GAAGF,yBAAyB,CAAU;;AAElG,OAAO,MAAMoB,CAAC,GAAGxB,aAAa,CAACsB,qBAAqB,CAAC;;AAErDE,CAAC,CAACC,IAAI,CAAC,mBAAmB,CAAC;AACxBC,OAAO,CAAC,gDAAgD,CAAC;AACzDC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAEvB,aAAa,CAAC;AAC/BuB,OAAO,CAAC,QAAQ,EAAEP,qBAAqB,CAAC;AACxCQ,MAAM,CAAC,CAAAC,CAAC,KAAId,kCAAkC,CAACc,CAAC,CAACC,MAAM,CAAC,CAAC;AACzDC,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAEV,mBAAmB,CAAC;AAC5CU,OAAO,CAAC,cAAc,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC9EA,OAAO,CAAC,cAAc,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC9EA,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDA,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU;AAC7C,CAAC;AACAK,iBAAiB,CAAC,CAAAH,CAAC;AAClBX,0DAA0D,CAACW,CAAC,EAAEA,CAAC,CAACJ,MAAM,CAACK,MAAM;AAC/E,CAAC;AACAG,EAAE,CAAC,OAAMJ,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEI,KAAK,EAAEC,YAAY,EAAEC,YAAY,EAAEC,YAAY,EAAEC,SAAS,EAAEC,MAAM,CAAC,CAAC,GAAGV,CAAC,CAACJ,MAAM;;EAE/F;EACA,MAAM,CAACe,KAAK,EAAEC,MAAM,CAAC,GAAGlC,iBAAiB,CAAC,EAAEmC,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEb,MAAM,CAAC,CAAC,CAAC;EAC/E,MAAMc,UAAgC,GAAG;IACvCd,MAAM;IACNe,IAAI,EAAE,EAAEL,KAAK,EAAEC,MAAM,CAAC,CAAC;IACvBK,aAAa,EAAE,CAAC;IAChBC,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE;EACpD,CAAC;EACD,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAM5C,uCAAuC,CAACqB,CAAC,EAAEe,UAAU,CAAC;EACxF,MAAMS,OAA6B,GAAG;IACpCjB,YAAY;IACZC,YAAY;IACZC,SAAS;IACTgB,SAAS,EAAEhB,SAAS;IACpBiB,YAAY,EAAEjB;EAChB,CAAC;;EAED,MAAMkB,KAA0B,GAAG7C,8BAA8B,CAAC,EAAE,EAAE;IACpE8C,MAAM,EAAEtB,YAAY;IACpBkB,OAAO;IACPT,UAAU;IACVc,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,EAAEc,IAAI,EAAE,KAAK,CAAC,CAAC;IACrDrB,MAAM;IACNsB,UAAU,EAAE,CAAC3B,KAAK,EAAEJ,MAAM,EAAEK,YAAY,EAAEC,YAAY,EAAEC,YAAY,EAAEC,SAAS,EAAEC,MAAM;EACzF,CAAC,CAAC,CAACuB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEL,QAAQ,EAAEnB,MAAM,CAAC,CAAC,KAAK;IACvC,OAAO;MACLyB,OAAO,EAAE,oBAAoB;MAC7BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNL,QAAQ;MACRQ,SAAS,EAAE,GAAG;MACd3B;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAM4B,WAAW,GAAG9D,yCAAyC,CAAC,YAAY,EAAEyB,MAAM,CAAC;EACnF,MAAMsC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,OAAO,GAAG,MAAM5D,cAAc;IAClCoB,CAAC;IACDuB,OAAO;IACPgB,cAAc;IACdD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLtB;EACF,CAAC;EACD,MAAMoC,GAAG,GAAG,MAAMhE,gBAAgB;IAChCuB,CAAC;IACD,EAAEsB,MAAM,EAAEP,UAAU,EAAEwB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLa,OAAO;IACPnC;EACF,CAAC;EACDL,CAAC,CAAC0C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJjD,CAAC,CAACC,IAAI,CAAC,yBAAyB,CAAC;AAC9BC,OAAO,CAAC,gDAAgD,CAAC;AACzDC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAEvB,aAAa,CAAC;AAC/BuB,OAAO,CAAC,QAAQ,EAAEP,qBAAqB,CAAC;AACxCQ,MAAM,CAAC,CAAAC,CAAC,KAAId,kCAAkC,CAACc,CAAC,CAACC,MAAM,CAAC,CAAC;AACzDC,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAEV,mBAAmB,CAAC;AAC5CU,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,cAAc,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC9EA,OAAO,CAAC,cAAc,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC9EA,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDA,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU;AAC7C,CAAC;AACAK,iBAAiB,CAAC,CAAAH,CAAC;AAClBX,0DAA0D,CAACW,CAAC,EAAEA,CAAC,CAACJ,MAAM,CAACK,MAAM;AAC/E,CAAC;AACAG,EAAE,CAAC,OAAMJ,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEI,KAAK,EAAEC,YAAY,EAAEqC,CAAC,EAAEpC,YAAY,EAAEC,YAAY,EAAEC,SAAS,EAAEC,MAAM,CAAC,CAAC;EACrFV,CAAC,CAACJ,MAAM;;EAEV;EACA,MAAM,CAACe,KAAK,EAAEC,MAAM,CAAC,GAAGlC,iBAAiB,CAAC,EAAEmC,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEb,MAAM,CAAC,CAAC,CAAC;EAC/E,MAAM2C,kBAAkB,GAAG,CAAC;;EAE5B,MAAM7B,UAAgC,GAAG;IACvCd,MAAM;IACNe,IAAI,EAAE,EAAEL,KAAK,EAAEC,MAAM,EAAEgC,kBAAkB,CAAC,CAAC;IAC3C3B,aAAa,EAAE,CAAC;IAChBC,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE;EACpD,CAAC;EACD,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAM5C,uCAAuC,CAACqB,CAAC,EAAEe,UAAU,CAAC;EACxF,MAAMS,OAA6B,GAAG;IACpCjB,YAAY;IACZC,YAAY;IACZC,SAAS;IACTgB,SAAS,EAAEhB,SAAS;IACpBiB,YAAY,EAAEjB;EAChB,CAAC;;EAED,MAAMkB,KAA0B,GAAG7C,8BAA8B,CAAC,EAAE,EAAE;IACpE8C,MAAM,EAAEtB,YAAY;IACpBkB,OAAO;IACPT,UAAU;IACVc,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,EAAEc,IAAI,EAAE,KAAK,CAAC,CAAC;IACrDc,UAAU,EAAE,EAAEf,GAAG,EAAEP,OAAO,CAACqB,kBAAkB,EAAEb,IAAI,EAAEY,CAAC,CAAC,CAAC;IACxDjC,MAAM;IACNsB,UAAU,EAAE,CAAC3B,KAAK,EAAEJ,MAAM,EAAEK,YAAY,EAAEqC,CAAC,EAAEpC,YAAY,EAAEC,YAAY,EAAEC,SAAS,EAAEC,MAAM;EAC5F,CAAC,CAAC,CAACuB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEL,QAAQ,EAAEgB,UAAU,EAAEnC,MAAM,CAAC,CAAC,KAAK;IACnD,OAAO;MACLyB,OAAO,EAAE,oBAAoB;MAC7BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNL,QAAQ;MACRQ,SAAS,EAAE,GAAG;MACdQ,UAAU;MACVC,cAAc,EAAEH,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;MACvCjC;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAM4B,WAAW,GAAG9D,yCAAyC,CAAC,kBAAkB,EAAEyB,MAAM,CAAC;EACzF,MAAMsC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,OAAO,GAAG,MAAM5D,cAAc;IAClCoB,CAAC;IACDuB,OAAO;IACPgB,cAAc;IACdD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLtB;EACF,CAAC;EACD,MAAMoC,GAAG,GAAG,MAAMhE,gBAAgB;IAChCuB,CAAC;IACD,EAAEsB,MAAM,EAAEP,UAAU,EAAEwB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLa,OAAO;IACPnC;EACF,CAAC;EACDL,CAAC,CAAC0C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJjD,CAAC,CAACC,IAAI,CAAC,mBAAmB,CAAC;AACxBC,OAAO,CAAC,gDAAgD,CAAC;AACzDC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAEvB,aAAa,CAAC;AAC/BuB,OAAO,CAAC,QAAQ,EAAEP,qBAAqB,CAAC;AACxCQ,MAAM,CAAC,CAAAC,CAAC,KAAId,kCAAkC,CAACc,CAAC,CAACC,MAAM,CAAC,CAAC;AACzDH,OAAO,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,MAAM,CAAU,CAAC;AACjDC,MAAM,CAAC,CAAAC,CAAC,KAAI,CAAC/B,yBAAyB,CAAC+B,CAAC,CAACC,MAAM,CAAC,IAAID,CAAC,CAAC+C,aAAa,KAAK,MAAM,CAAC;AAC/E7C,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAEX,uBAAuB,CAAC;AAChDY,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACM,YAAY,KAAK,YAAY,IAAIN,CAAC,CAAC+C,aAAa,KAAK,IAAI,CAAC;AACxEjD,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDA,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU,CAAC;AACzCC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAAC+C,aAAa,KAAK,MAAM,IAAI/C,CAAC,CAACU,MAAM,KAAK,IAAI;AAChE,CAAC;AACAP,iBAAiB,CAAC,CAAAH,CAAC;AAClBX,0DAA0D,CAACW,CAAC,EAAEA,CAAC,CAACJ,MAAM,CAACK,MAAM;AAC/E,CAAC;AACAG,EAAE,CAAC,OAAMJ,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAE8C,aAAa,EAAE1C,KAAK,EAAEC,YAAY,EAAE0C,WAAW,EAAEvC,SAAS,EAAEC,MAAM,CAAC,CAAC,GAAGV,CAAC,CAACJ,MAAM;;EAE/F,MAAM,CAACe,KAAK,EAAEC,MAAM,CAAC,GAAGlC,iBAAiB,CAAC,EAAEmC,OAAO,EAAE,EAAE,EAAEC,SAAS,EAAE,CAAC,EAAEb,MAAM,EAAE8C,aAAa,CAAC,CAAC,CAAC;EAC/F,MAAMH,kBAAkB,GAAG5D,qCAAqC,CAAC+D,aAAa,CAAC;;EAE/E,MAAMhC,UAAgC,GAAG;IACvCd,MAAM;IACNgD,SAAS,EAAEF,aAAa,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI;IAC/C,IAAI/C,CAAC,CAACkD,eAAe,IAAI,EAAEC,2BAA2B,EAAEJ,aAAa,CAAC,CAAC,CAAC;IACxE/B,IAAI,EAAE,EAAEL,KAAK,EAAEC,MAAM,EAAEgC,kBAAkB,CAAC,CAAC;IAC3C1B,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE,eAAe;IACjEJ,aAAa,EAAE;EACjB,CAAC;EACD,MAAM,EAAEK,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAM5C,uCAAuC,CAACqB,CAAC,EAAEe,UAAU,CAAC;EACxF,MAAMS,OAA6B,GAAG;IACpCjB,YAAY,EAAEyC,WAAW;IACzBxC,YAAY,EAAEwC,WAAW;IACzBI,YAAY,EAAEJ,WAAW;IACzBvC,SAAS;IACTgB,SAAS,EAAEhB,SAAS;IACpBiB,YAAY,EAAEjB;EAChB,CAAC;;EAED,MAAMuB,UAAU,GAAG,CAAC3B,KAAK,EAAEJ,MAAM,EAAE8C,aAAa,EAAEzC,YAAY,EAAE0C,WAAW,EAAEvC,SAAS,EAAEC,MAAM,CAAC;EAC/F,MAAMiB,KAA0B,GAAG;EACjCoB,aAAa,KAAK,IAAI;EAClBhE,8BAA8B,CAAC,EAAE,EAAE;IACjC6C,MAAM,EAAEtB,YAAkC;IAC1CkB,OAAO;IACPT,UAAU;IACVc,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,EAAEc,IAAI,EAAE,KAAK,CAAC,CAAC;IACrDrB,MAAM;IACNsB;EACF,CAAC,CAAC;EACFnD,wBAAwB,CAAC,EAAE,EAAE;IAC3B+C,MAAM,EAAEtB,YAAY;IACpBkB,OAAO;IACPT,UAAU;IACVc,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,EAAEc,IAAI,EAAE,KAAK,CAAC,CAAC;IACrDC;EACF,CAAC,CAAC;EACNC,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEL,QAAQ,EAAEnB,MAAM,CAAC,CAAC,KAAK;IACtC,OAAO;MACLyB,OAAO,EAAE,oBAAoB;MAC7BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNL,QAAQ;MACRQ,SAAS,EAAE,GAAG;MACd3B;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAM6B,cAAc,GAAG;IACrBU,SAAS,EAAEF;EACb,CAAC;EACD,MAAMT,WAAW,GAAGrD,qCAAqC,CAAC8D,aAAa,CAAC;EACxE,MAAMP,OAAO,GAAG,MAAM5D,cAAc;IAClCoB,CAAC;IACDuB,OAAO;IACPgB,cAAc;IACdD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLtB;EACF,CAAC;EACD,MAAMoC,GAAG,GAAG,MAAMhE,gBAAgB;IAChCuB,CAAC;IACD,EAAEsB,MAAM,EAAEP,UAAU,EAAEwB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLa,OAAO;IACPnC;EACF,CAAC;EACDL,CAAC,CAAC0C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJjD,CAAC,CAACC,IAAI,CAAC,yBAAyB,CAAC;AAC9BC,OAAO,CAAC,gDAAgD,CAAC;AACzDC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAEvB,aAAa,CAAC;AAC/BuB,OAAO,CAAC,QAAQ,EAAEP,qBAAqB,CAAC;AACxCQ,MAAM,CAAC,CAAAC,CAAC,KAAId,kCAAkC,CAACc,CAAC,CAACC,MAAM,CAAC,CAAC;AACzDC,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAEX,uBAAuB,CAAC;AAChDW,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU;AACxD,CAAC;AACAK,iBAAiB,CAAC,CAAAH,CAAC,KAAI;EACtBX,0DAA0D,CAACW,CAAC,EAAEA,CAAC,CAACJ,MAAM,CAACK,MAAM,CAAC;EAC9ED,CAAC,CAACqD,sCAAsC,CAAC,YAAY,CAAC;AACxD,CAAC,CAAC;AACDjD,EAAE,CAAC,OAAMJ,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEI,KAAK,EAAEC,YAAY,EAAEqC,CAAC,EAAEK,WAAW,EAAEvC,SAAS,CAAC,CAAC,GAAGT,CAAC,CAACJ,MAAM;;EAE3E,MAAMmD,aAAsC,GAAG,YAAY;EAC3D,MAAM/B,IAAI,GAAGtC,iBAAiB,CAAC;IAC7BmC,OAAO,EAAE,EAAE;IACXC,SAAS,EAAE,CAAC;IACZb,MAAM;IACN8C;EACF,CAAC,CAAC;EACF,MAAMhC,UAAgC,GAAG;IACvCd,MAAM;IACNe,IAAI;IACJE,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE,eAAe;IACjEJ,aAAa,EAAE;EACjB,CAAC;EACD,MAAM,EAAEK,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAM5C,uCAAuC,CAACqB,CAAC,EAAEe,UAAU,CAAC;EACxF,MAAMS,OAA6B,GAAG;IACpCjB,YAAY,EAAEyC,WAAW;IACzBxC,YAAY,EAAEwC,WAAW;IACzBI,YAAY,EAAEJ,WAAW;IACzBvC,SAAS;IACTgB,SAAS,EAAEhB,SAAS;IACpBiB,YAAY,EAAEjB;EAChB,CAAC;;EAED,MAAMkB,KAA0B,GAAG9C,wBAAwB,CAAC,EAAE,EAAE;IAC9D+C,MAAM,EAAEtB,YAAY;IACpBkB,OAAO;IACPT,UAAU;IACVc,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,EAAEc,IAAI,EAAE,KAAK,CAAC,CAAC;IACrDc,UAAU,EAAE,EAAEf,GAAG,EAAEP,OAAO,CAACqB,kBAAkB,GAAG,CAAC,EAAEb,IAAI,EAAEY,CAAC,CAAC,CAAC;IAC5DX,UAAU,EAAE,CAAC3B,KAAK,EAAEJ,MAAM,EAAE8C,aAAa,EAAEJ,CAAC,EAAErC,YAAY,EAAE0C,WAAW,EAAEvC,SAAS;EACpF,CAAC,CAAC,CAACwB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEL,QAAQ,EAAEgB,UAAU,CAAC,CAAC,KAAK;IAC3C,OAAO;MACLV,OAAO,EAAE,oBAAoB;MAC7BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNL,QAAQ;MACRQ,SAAS,EAAE,GAAG;MACdQ,UAAU;MACVC,cAAc,EAAEH,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG;IACtC,CAAC;EACH,CAAC,CAAC;EACF,MAAMJ,cAAc,GAAG;IACrBU,SAAS,EAAEF;EACb,CAAC;EACD,MAAMT,WAAW,GAAGrD,qCAAqC,CAAC8D,aAAa,CAAC;EACxE,MAAMP,OAAO,GAAG,MAAM5D,cAAc;IAClCoB,CAAC;IACDuB,OAAO;IACPgB,cAAc;IACdD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLtB;EACF,CAAC;EACD,MAAMoC,GAAG,GAAG,MAAMhE,gBAAgB;IAChCuB,CAAC;IACD,EAAEsB,MAAM,EAAEP,UAAU,EAAEwB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLa,OAAO;IACPnC;EACF,CAAC;EACDL,CAAC,CAAC0C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJjD,CAAC,CAACC,IAAI,CAAC,iBAAiB,CAAC;AACtBC,OAAO,CAAC,gDAAgD,CAAC;AACzDC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAEvB,aAAa,CAAC;AAC/BuB,OAAO,CAAC,QAAQ,EAAEzB,oBAAoB;AACvC;AAAA,CACC0B,MAAM,CAAC,CAAAC,CAAC,KAAI9B,oBAAoB,CAAC8B,CAAC,CAACC,MAAM,CAAC;AAC3C;AAAA,CACCF,MAAM,CAAC,CAAAC,CAAC,KAAI7B,wBAAwB,CAAC6B,CAAC,CAACC,MAAM,CAAC,CAAC;AAC/CC,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAEV,mBAAmB,CAAC;AAC5CU,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDA,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU;AAC7C,CAAC;AACAK,iBAAiB,CAAC,CAAAH,CAAC;AAClBX,0DAA0D,CAACW,CAAC,EAAEA,CAAC,CAACJ,MAAM,CAACK,MAAM;AAC/E,CAAC;AACAG,EAAE,CAAC,OAAMJ,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEI,KAAK,EAAEC,YAAY,EAAE0C,WAAW,EAAEvC,SAAS,EAAE6C,CAAC,EAAE5C,MAAM,CAAC,CAAC,GAAGV,CAAC,CAACJ,MAAM;;EAEnF;EACA,MAAM,CAACe,KAAK,EAAEC,MAAM,CAAC,GAAGlC,iBAAiB,CAAC,EAAEmC,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEb,MAAM,CAAC,CAAC,CAAC;EAC/E,MAAMc,UAAgC,GAAG;IACvCd,MAAM;IACNe,IAAI,EAAE,EAAEL,KAAK,EAAEC,MAAM,CAAC,CAAC;IACvBK,aAAa,EAAE,CAAC;IAChBC,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE;EACpD,CAAC;EACD,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAM5C,uCAAuC,CAACqB,CAAC,EAAEe,UAAU,CAAC;EACxF,MAAMS,OAA6B,GAAG;IACpCjB,YAAY,EAAEyC,WAAW;IACzBxC,YAAY,EAAEwC,WAAW;IACzBvC,SAAS;IACTgB,SAAS,EAAEhB,SAAS;IACpBiB,YAAY,EAAEjB;EAChB,CAAC;;EAED,MAAMkB,KAA0B,GAAG7C,8BAA8B,CAAC,EAAE,EAAE;IACpE8C,MAAM,EAAEtB,YAAY;IACpBkB,OAAO;IACPT,UAAU;IACVc,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,EAAEc,IAAI,EAAEuB,CAAC,CAAC,CAAC;IACjD5C,MAAM;IACNsB,UAAU,EAAE,CAAC3B,KAAK,EAAEJ,MAAM,EAAEK,YAAY,EAAE0C,WAAW,EAAEvC,SAAS,EAAE6C,CAAC,EAAE5C,MAAM;EAC7E,CAAC,CAAC,CAACuB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEL,QAAQ,EAAEnB,MAAM,CAAC,CAAC,KAAK;IACvC,OAAO;MACLyB,OAAO,EAAE,oBAAoB;MAC7BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNL,QAAQ;MACRQ,SAAS,EAAEiB,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;MAClC5C;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAM4B,WAAW,GAAG9D,yCAAyC,CAAC,kBAAkB,EAAEyB,MAAM,CAAC;EACzF,MAAMsC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,OAAO,GAAG,MAAM5D,cAAc;IAClCoB,CAAC;IACDuB,OAAO;IACPgB,cAAc;IACdD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLtB;EACF,CAAC;EACD,MAAMoC,GAAG,GAAG,MAAMhE,gBAAgB;IAChCuB,CAAC;IACD,EAAEsB,MAAM,EAAEP,UAAU,EAAEwB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLa,OAAO;IACPnC;EACF,CAAC;EACDL,CAAC,CAAC0C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJjD,CAAC,CAACC,IAAI,CAAC,uBAAuB,CAAC;AAC5BC,OAAO,CAAC,gDAAgD,CAAC;AACzDC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAEvB,aAAa,CAAC;AAC/BuB,OAAO,CAAC,QAAQ,EAAEzB,oBAAoB;AACvC;AAAA,CACC0B,MAAM,CAAC,CAAAC,CAAC,KAAI9B,oBAAoB,CAAC8B,CAAC,CAACC,MAAM,CAAC;AAC3C;AAAA,CACCF,MAAM,CAAC,CAAAC,CAAC,KAAI7B,wBAAwB,CAAC6B,CAAC,CAACC,MAAM,CAAC,CAAC;AAC/CC,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAEV,mBAAmB,CAAC;AAC5CU,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDA,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU;AAC7C,CAAC;AACAK,iBAAiB,CAAC,CAAAH,CAAC;AAClBX,0DAA0D,CAACW,CAAC,EAAEA,CAAC,CAACJ,MAAM,CAACK,MAAM;AAC/E,CAAC;AACAG,EAAE,CAAC,OAAMJ,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEI,KAAK,EAAEC,YAAY,EAAE0C,WAAW,EAAEvC,SAAS,EAAEkC,CAAC,EAAEW,CAAC,EAAE5C,MAAM,CAAC,CAAC,GAAGV,CAAC,CAACJ,MAAM;;EAEtF;EACA,MAAM,CAACe,KAAK,EAAEC,MAAM,CAAC,GAAGlC,iBAAiB,CAAC,EAAEmC,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEb,MAAM,CAAC,CAAC,CAAC;EAC/E,MAAMc,UAAgC,GAAG;IACvCd,MAAM;IACNe,IAAI,EAAE,EAAEL,KAAK,EAAEC,MAAM,CAAC,CAAC;IACvBK,aAAa,EAAE,CAAC;IAChBC,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE,eAAe;IACjE,IAAIrB,CAAC,CAACkD,eAAe,IAAI,EAAEC,2BAA2B,EAAE,UAAU,CAAC,CAAC;EACtE,CAAC;EACD,MAAM,EAAE7B,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAM5C,uCAAuC,CAACqB,CAAC,EAAEe,UAAU,CAAC;EACxF,MAAMS,OAA6B,GAAG;IACpCjB,YAAY,EAAEyC,WAAW;IACzBxC,YAAY,EAAEwC,WAAW;IACzBvC,SAAS;IACTgB,SAAS,EAAEhB,SAAS;IACpBiB,YAAY,EAAEjB;EAChB,CAAC;;EAED,MAAMkB,KAA0B,GAAG7C,8BAA8B,CAAC,EAAE,EAAE;IACpE8C,MAAM,EAAEtB,YAAY;IACpBkB,OAAO;IACPT,UAAU;IACV8B,UAAU,EAAE,EAAEf,GAAG,EAAEP,OAAO,CAACqB,kBAAkB,EAAEb,IAAI,EAAEY,CAAC,CAAC,CAAC;IACxDd,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,EAAEc,IAAI,EAAEuB,CAAC,CAAC,CAAC;IACjD5C,MAAM;IACNsB,UAAU,EAAE,CAAC3B,KAAK,EAAEJ,MAAM,EAAEK,YAAY,EAAE0C,WAAW,EAAEvC,SAAS,EAAE6C,CAAC,EAAEX,CAAC,EAAEjC,MAAM;EAChF,CAAC,CAAC,CAACuB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEL,QAAQ,EAAEgB,UAAU,EAAEnC,MAAM,CAAC,CAAC,KAAK;IACnD,OAAO;MACLyB,OAAO,EAAE,oBAAoB;MAC7BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNL,QAAQ;MACRQ,SAAS,EAAEiB,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;MAClCT,UAAU;MACVC,cAAc,EAAEH,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;MACvCjC;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAM4B,WAAW,GAAG9D,yCAAyC,CAAC,wBAAwB,EAAEyB,MAAM,CAAC;EAC/F,MAAMsC,cAAwC,GAAG,EAAEU,SAAS,EAAE,UAAU,CAAC,CAAC;EAC1E,MAAMT,OAAO,GAAG,MAAM5D,cAAc;IAClCoB,CAAC;IACDuB,OAAO;IACPgB,cAAc;IACdD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLtB;EACF,CAAC;EACD,MAAMoC,GAAG,GAAG,MAAMhE,gBAAgB;IAChCuB,CAAC;IACD,EAAEsB,MAAM,EAAEP,UAAU,EAAEwB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLa,OAAO;IACPnC;EACF,CAAC;EACDL,CAAC,CAAC0C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJjD,CAAC,CAACC,IAAI,CAAC,iBAAiB,CAAC;AACtBC,OAAO,CAAC,gDAAgD,CAAC;AACzDC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAEvB,aAAa,CAAC;AAC/BuB,OAAO,CAAC,QAAQ,EAAEzB,oBAAoB;AACvC;AAAA,CACC0B,MAAM,CAAC,CAAAC,CAAC,KAAI9B,oBAAoB,CAAC8B,CAAC,CAACC,MAAM,CAAC;AAC3C;AAAA,CACCF,MAAM,CAAC,CAAAC,CAAC,KAAI7B,wBAAwB,CAAC6B,CAAC,CAACC,MAAM,CAAC,CAAC;AAC/CsD,iBAAiB,CAAC;AACjB,EAAER,aAAa,EAAE,MAAM,CAAC,CAAC;AACzB,EAAEA,aAAa,EAAE,YAAY,EAAEJ,CAAC,EAAE,KAAK,CAAC,CAAC;AACzC,EAAEI,aAAa,EAAE,YAAY,EAAEJ,CAAC,EAAE,KAAK,CAAC,CAAC;AACjC,CAAC;AACVzC,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAEX,uBAAuB,CAAC;AAChDW,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU;AACxD,CAAC;AACAK,iBAAiB,CAAC,CAAAH,CAAC,KAAI;EACtBX,0DAA0D,CAACW,CAAC,EAAEA,CAAC,CAACJ,MAAM,CAACK,MAAM,CAAC;EAC9ED,CAAC,CAACqD,sCAAsC,CAACrD,CAAC,CAACJ,MAAM,CAACmD,aAAa,CAAC;AAClE,CAAC,CAAC;AACD3C,EAAE,CAAC,OAAMJ,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEI,KAAK,EAAE0C,aAAa,EAAEzC,YAAY,EAAEqC,CAAC,EAAEW,CAAC,EAAEN,WAAW,EAAEvC,SAAS,CAAC,CAAC,GAAGT,CAAC,CAACJ,MAAM;;EAE7F,MAAMoB,IAAI,GAAGtC,iBAAiB,CAAC;IAC7BmC,OAAO,EAAE,EAAE;IACXC,SAAS,EAAE,CAAC;IACZb,MAAM;IACN8C;EACF,CAAC,CAAC;EACF,MAAMhC,UAAgC,GAAG;IACvCd,MAAM;IACNe,IAAI;IACJE,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE,eAAe;IACjEJ,aAAa,EAAE,CAAC;IAChB,IAAIjB,CAAC,CAACkD,eAAe,IAAI,EAAEC,2BAA2B,EAAEJ,aAAa,CAAC,CAAC;EACzE,CAAC;EACD,MAAM,EAAEzB,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAM5C,uCAAuC,CAACqB,CAAC,EAAEe,UAAU,CAAC;EACxF,MAAMS,OAA6B,GAAG;IACpCjB,YAAY,EAAEyC,WAAW;IACzBxC,YAAY,EAAEwC,WAAW;IACzBI,YAAY,EAAEJ,WAAW;IACzBvC,SAAS;IACTgB,SAAS,EAAEhB,SAAS;IACpBiB,YAAY,EAAEjB;EAChB,CAAC;;EAED,MAAMkB,KAA0B,GAAG9C,wBAAwB,CAAC,EAAE,EAAE;IAC9D+C,MAAM,EAAEtB,YAAY;IACpBkB,OAAO;IACPT,UAAU;IACVc,QAAQ,EAAE,EAAEC,GAAG,EAAEP,OAAO,CAACN,aAAa,GAAG,CAAC,EAAEc,IAAI,EAAEuB,CAAC,CAAC,CAAC;IACrDT,UAAU,EAAEF,CAAC,GAAG,EAAEb,GAAG,EAAEP,OAAO,CAACqB,kBAAkB,GAAG,CAAC,EAAEb,IAAI,EAAEY,CAAC,CAAC,CAAC,GAAGa,SAAS;IAC5ExB,UAAU,EAAE,CAAC3B,KAAK,EAAEJ,MAAM,EAAE8C,aAAa,EAAEzC,YAAY,EAAE0C,WAAW,EAAEvC,SAAS;EACjF,CAAC,CAAC,CAACwB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEL,QAAQ,EAAEgB,UAAU,CAAC,CAAC,KAAK;IAC3C,OAAO;MACLV,OAAO,EAAE,oBAAoB;MAC7BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNL,QAAQ;MACRQ,SAAS,EAAEiB,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;MAClCT,UAAU;MACVC,cAAc,EAAEH,CAAC,GAAIA,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG,GAAIa;IAClD,CAAC;EACH,CAAC,CAAC;EACF,MAAMjB,cAAc,GAAG;IACrBU,SAAS,EAAEF;EACb,CAAC;EACD,MAAMT,WAAW;EACfS,aAAa,KAAK,MAAM,GAAG,oBAAoB,GAAG,0BAA0B;EAC9E,MAAMP,OAAO,GAAG,MAAM5D,cAAc;IAClCoB,CAAC;IACDuB,OAAO;IACPgB,cAAc;IACdD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLtB;EACF,CAAC;;EAED,MAAMoC,GAAG,GAAG,MAAMhE,gBAAgB;IAChCuB,CAAC;IACD,EAAEsB,MAAM,EAAEP,UAAU,EAAEwB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXd,OAAO;IACPG,KAAK;IACLa,OAAO;IACPnC;EACF,CAAC;EACDL,CAAC,CAAC0C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC"}